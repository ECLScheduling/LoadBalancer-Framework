#pragma once

#include <abstractions/rts.h>
#include <system/traits/rts.h>

#include <vector>

namespace MOGSLib { namespace Abstraction {

/**
 * @brief The declaration of a specific data structure to represent the Charm++ runtime system.
 * @details This structure must contain solely static data.
 */
template<>
struct RTS<MOGSLib::RuntimeSystemEnum::Charm> {
  static constexpr auto id = RuntimeSystemEnum::Charm;
  using Traits = RuntimeTraits<id>;

  static constexpr auto name = Traits::name;
  using Index = typename Traits::Index;
  using Load = typename Traits::Load;

  // Having this typedef requires that the LDStats type have been declared before the compiler analyzes this header (include it after Charm++ includes).
  using LDStats = BaseLB::LDStats*;
  
  /**
   * @brief Charm++ system must be aware of the chare_ids and pu_ids in order to apply the task mapping generated by the global scheduler.
   */
  static std::vector<Index> chare_ids, pu_ids;
  /**
   * @brief A pointer to the load balancer data within Charm++ runtime system.
   */
  static LDStats stats;

  /**
   * @brief A static structure that represents the capabilities of the Charm++ LBDB system.
   */
  struct LBDB {
    /**
     * @brief A static structure that represents the capabilities of the Charm++ LBDB system for acquiring PU data.
     */
    struct PU {
      using Charm = RTS<MOGSLib::RuntimeSystemEnum::Charm>;
      /**
       * @brief Get the amount of PUs in the Charm++ system.
       * @details This function yields different semantics based on the check_for_unavailable_pus trait of the Charm++ system.
       */
      static Index count();

      /**
       * @brief Get the PUs predicted load based on background load and fixed chares.
       * @details This method must be called after PU::count as it searches only the PUs whose ids are in Charm::pu_ids.
       */
      static std::vector<Load> load_prediction();

      private:

      /**
       * @brief Get the amount of PUs in the Charm++ system filtering out the unavailable PUs.
       */
      template<bool Aware = Traits::check_for_unavailable_pus>
      static void filter_unavailable(const unsigned &index);

      /**
       * @brief Calculate the loads of fixed chares and add them to host pus.
       */
      template<bool Aware = Traits::check_for_fixed_chares>
      static void add_load_from_fixed_chares(std::vector<Load> &loads);

      /**
       * @brief Commit the load addition of fixed chares into the host pus.
       */
      template<bool Aware = Traits::check_for_unavailable_pus>
      static void apply_fixed_chares_load(std::vector<Load> &loads, std::vector<std::pair<Index, Load>> &fixed_chares);
    };

    /**
     * @brief A static structure that represents the capabilities of the Charm++ LBDB system for acquiring chare's data.
     */
    struct Chare {
      using Charm = LBDB::PU::Charm;
      /**
       * @brief Get the amount of chares in the Charm++ system.
       * @details This function yields different semantics based on the check_for_fixed_chares trait of the Charm++ system.
       */
      static Index count();

      /**
       * @brief Get the chares predicted load based on the processor speed and time to complete on previous iterations.
       * @details This method must be called after Chare::count as it searches only the task whose ids are in Charm::chare_ids.
       */
      static std::vector<Load> load_prediction();

      private:
      /**
       * @brief Get the amount of chares in the Charm++ system filtering out the unmigratable chares.
       */
      template<bool Aware = Traits::check_for_fixed_chares>
      static void filter_unmigratable(const unsigned &index);
    };

  };
};

}}